// Copyright (c) 2025 Zhao Jiabing
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

/**
 * @file main.cc
 * @brief YOLOv8圆形检测主程序
 * @author Generated by Copilot
 * @date 2025-07-13
 */

#include "yolov8_detector.h"
#include <opencv2/opencv.hpp>
#include <iostream>
#include <filesystem>
#include <string>
#include <vector>
#include <iomanip>
#include <chrono>
#include <algorithm>

namespace fs = std::filesystem;

/**
 * @brief 检查文件是否为图像
 * @param path 文件路径
 * @return 是否为图像文件
 */
bool isImageFile(const std::string& path) {
    std::vector<std::string> extensions = {".jpg", ".jpeg", ".png", ".bmp", ".JPG", ".JPEG", ".PNG", ".BMP"};
    
    for (const auto& ext : extensions) {
        if (path.size() >= ext.size() && 
            path.substr(path.size() - ext.size()) == ext) {
            return true;
        }
    }
    return false;
}

/**
 * @brief 打印使用说明
 * @param program_name 程序名称
 */
void printUsage(const char* program_name) {
    std::cout << "YOLOv8 圆形检测推理程序\n\n";
    std::cout << "使用方法:\n";
    std::cout << "  " << program_name << " --model_path <model.onnx> [选项]\n\n";
    std::cout << "必需参数:\n";
    std::cout << "  --model_path     ONNX模型文件路径\n\n";
    std::cout << "可选参数:\n";
    std::cout << "  --img_path       单张图像路径\n";
    std::cout << "  --img_folder     图像文件夹路径 (默认: ./images)\n";
    std::cout << "  --img_show       显示检测结果\n";
    std::cout << "  --img_save       保存检测结果到./result文件夹\n";
    std::cout << "  --obj_thresh     目标检测阈值 (默认: 0.25)\n";
    std::cout << "  --nms_thresh     NMS阈值 (默认: 0.45)\n";
    std::cout << "  --help, -h       显示此帮助信息\n\n";
    std::cout << "示例:\n";
    std::cout << "  " << program_name << " --model_path model.onnx --img_folder ./images --img_save\n";
    std::cout << "  " << program_name << " --model_path model.onnx --img_path single.jpg --img_show\n";
}

/**
 * @brief 解析命令行参数
 */
struct Args {
    std::string model_path;
    std::string img_path;
    std::string img_folder = "./images";
    bool img_show = false;
    bool img_save = false;
    float obj_thresh = 0.25f;
    float nms_thresh = 0.45f;
    bool help = false;
};

Args parseArgs(int argc, char* argv[]) {
    Args args;
    
    for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];
        
        if (arg == "--help" || arg == "-h") {
            args.help = true;
        } else if (arg == "--model_path" && i + 1 < argc) {
            args.model_path = argv[++i];
        } else if (arg == "--img_path" && i + 1 < argc) {
            args.img_path = argv[++i];
        } else if (arg == "--img_folder" && i + 1 < argc) {
            args.img_folder = argv[++i];
        } else if (arg == "--img_show") {
            args.img_show = true;
        } else if (arg == "--img_save") {
            args.img_save = true;
        } else if (arg == "--obj_thresh" && i + 1 < argc) {
            args.obj_thresh = std::stof(argv[++i]);
        } else if (arg == "--nms_thresh" && i + 1 < argc) {
            args.nms_thresh = std::stof(argv[++i]);
        }
    }
    
    return args;
}

int main(int argc, char* argv[]) {
    // 解析命令行参数
    Args args = parseArgs(argc, argv);
    
    if (args.help || args.model_path.empty()) {
        printUsage(argv[0]);
        return args.help ? 0 : 1;
    }
    
    try {
        // 初始化检测器
        std::cout << "正在初始化YOLOv8检测器..." << std::endl;
        yolov8::YOLOv8Detector detector(args.model_path, cv::Size(640, 640), 
                                       args.obj_thresh, args.nms_thresh);
        std::cout << "检测器初始化完成!" << std::endl;
        
        // 准备图像列表
        std::vector<std::string> img_list;
        std::string img_folder;
        
        if (!args.img_path.empty() && fs::exists(args.img_path)) {
            // 单张图像推理
            img_list.push_back(fs::path(args.img_path).filename().string());
            img_folder = fs::path(args.img_path).parent_path().string();
            std::cout << "单张图像模式: " << args.img_path << std::endl;
        } else {
            // 批量推理
            img_folder = args.img_folder;
            if (fs::exists(img_folder) && fs::is_directory(img_folder)) {
                for (const auto& entry : fs::directory_iterator(img_folder)) {
                    if (entry.is_regular_file()) {
                        std::string filename = entry.path().filename().string();
                        if (isImageFile(filename)) {
                            img_list.push_back(filename);
                        }
                    }
                }
                std::sort(img_list.begin(), img_list.end());
                std::cout << "批量推理模式，找到 " << img_list.size() << " 张图像" << std::endl;
            } else {
                std::cerr << "图像文件夹不存在: " << img_folder << std::endl;
                return 1;
            }
        }
        
        if (img_list.empty()) {
            std::cout << "未找到图像文件!" << std::endl;
            return 1;
        }
        
        // 创建结果文件夹
        if (args.img_save) {
            if (!fs::exists("./result")) {
                fs::create_directory("./result");
            }
        }
        
        // 开始推理
        std::cout << "开始推理..." << std::endl;
        auto start_time = std::chrono::high_resolution_clock::now();
        
        for (size_t i = 0; i < img_list.size(); ++i) {
            std::cout << "推理进度: " << (i + 1) << "/" << img_list.size() << "\r" << std::flush;
            
            std::string img_name = img_list[i];
            std::string img_path = fs::path(img_folder) / img_name;
            
            if (!fs::exists(img_path)) {
                std::cout << "\n图像不存在: " << img_name << std::endl;
                continue;
            }
            
            // 读取图像
            cv::Mat img_src = cv::imread(img_path);
            if (img_src.empty()) {
                std::cout << "\n无法读取图像: " << img_name << std::endl;
                continue;
            }
            
            // 执行检测
            auto detections = detector.detect(img_src);
            
            if (args.img_show || args.img_save) {
                std::cout << "\n\n图像: " << img_name << std::endl;
                
                cv::Mat img_result = img_src.clone();
                if (!detections.empty()) {
                    detector.drawDetections(img_result, detections, true);
                } else {
                    std::cout << "未检测到目标" << std::endl;
                }
                
                // 保存结果
                if (args.img_save) {
                    std::string result_path = fs::path("./result") / img_name;
                    cv::imwrite(result_path, img_result);
                    std::cout << "检测结果已保存到: " << result_path << std::endl;
                }
                
                // 显示结果
                if (args.img_show) {
                    cv::imshow("YOLOv8 圆形检测结果", img_result);
                    std::cout << "按任意键继续..." << std::endl;
                    cv::waitKey(0);
                    cv::destroyAllWindows();
                }
            }
        }
        
        auto end_time = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
        
        std::cout << "\n\n推理完成!" << std::endl;
        std::cout << "总耗时: " << duration.count() << " ms" << std::endl;
        std::cout << "平均每张: " << std::fixed << std::setprecision(2) 
                 << static_cast<double>(duration.count()) / img_list.size() << " ms" << std::endl;
        
    } catch (const std::exception& e) {
        std::cerr << "错误: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}
